

[TOC]

参考博客：https://www.cnblogs.com/wupeiqi/articles/5444685.html

参考教程：https://www.runoob.com/python3/python3-string.html

## 1、基本数据类型

```python
#变量保留的关键字，查看方法
import keyword
print(keyword.kwlist)
#如下：
['False', 'None', 'True', 'and', 'as', 'assert', 'async', 'await', 'break', 'class', 'continue', 'def', 'del', 'elif', 'else', 'except', 'finally', 'for', 'from', 'global', 'if', 'import', 'in', 'is', 'lambda', 'nonlocal', 'not', 'or', 'pass', 'raise', 'return', 'try', 'while', 'with', 'yield']

#Python可以在同一行中使用多条语句，语句之间使用分号 ; 分割.如下：
import sys; x = 'runoob'; sys.stdout.write(x + '\n')

#算术运算符
5 + 4  # 加法 = 9
4.3 - 2 # 减法 = 2.3
3 * 7  # 乘法 = 21
2 / 4  # 除法，得到一个浮点数 = 0.5
2 // 4 # 除法，得到一个整数 = 0	所以除法有2个运算符
17 % 3 # 取余  = 2
2 ** 5 # 乘方 = 32

#比较运算符
10 == 20	# 返回 False
10 != 20	# 返回 True
10 > 20		# 返回 False
10 < 20		# 返回 True
10 >= 20 	# 返回 False
10 <= 20 	# 返回 True

#赋值运算符
c = 10 + 20 将 10 + 20 的运算结果赋值为 c
c += 10 等效于 c = c + 10
c -= 10 等效于 c = c - 10
c *= 10 等效于 c = c * 10
c /= 10 等效于 c = c / 10
c %= 10 等效于 c = c % 10
c **= 10 等效于 c = c ** 10
c //= 10 等效于 c = c // 10

#位运算符，按位运算符是把数字看作二进制来进行计算的
&	按位与运算符：参与运算的两个值,如果两个相应位都为1,则该位的结果为1,否则为0	
|	按位或运算符：只要对应的二个二进位有一个为1时，结果位就为1。
^	按位异或运算符：当两对应的二进位相异时，结果为1	
~	按位取反运算符：对数据的每个二进制位取反,即把1变为0,把0变为1。~x 类似于 -x-1
<<	左移动运算符：运算数的各二进位全部左移若干位，由"<<"右边的数指定移动的位数，高位丢弃，低位补0。	
>>	右移动运算符：把">>"左边的运算数的各二进位全部右移若干位，">>"右边的数指定移动的位数

#逻辑运算符
x and y	布尔"与" # 如果 x 为 False，x and y 返回 False，否则它返回 y 的计算值。
x or y	布尔"或" # 如果 x 是 True，它返回 x 的值，否则它返回 y 的计算值。
not x	布尔"非" # 如果 x 为 True，返回 False 。如果 x 为 False，它返回 True。

#成员运算符
in	如果在指定的序列中找到值返回 True，否则返回 False。
not in	如果在指定的序列中没有找到值返回 True，否则返回 False。

#身份运算符
is 是判断两个标识符是不是引用自一个对象,类似 x == y
is not 是判断两个标识符是不是引用自不同对象, 类似 x != y
```


```python
len() == 计算长度
str() == 变成字符串
int() == 变成数字
range(0,10) == 创建整数列表，一般用于for循环
type()  == 查看字符的类型
bytes() == 字节类型
enumerate() == 遍历数据对象，用法如下：
seq = ['one', 'two', 'three']
#--------------------------------------------------------------------
for i,j in enumerate(seq):
	print(i,j)
#显示如下
0 one
1 two
2 three
#------------------------------------------------------------------
end= '' == 不换行输出
#----------------------------------------------------------
print( x, end=" " )
print( y, end=" " )		#输出 a b
#---------------------------------------------
```

### 1.1、数据类型转换的方法

| 函数                                                         | 描述                                                |
| :----------------------------------------------------------- | :-------------------------------------------------- |
| int(x [,base\])](https://www.runoob.com/python3/python-func-int.html) | 将x转换为一个整数                                   |
| [float(x)](https://www.runoob.com/python3/python-func-float.html) | 将x转换到一个浮点数                                 |
| complex(real,[[imag\])](https://www.runoob.com/python3/python-func-complex.html) | 创建一个复数                                        |
| [str(x)](https://www.runoob.com/python3/python-func-str.html) | 将对象 x 转换为字符串                               |
| [repr(x)](https://www.runoob.com/python3/python-func-repr.html) | 将对象 x 转换为表达式字符串                         |
| [eval(str)](https://www.runoob.com/python3/python-func-eval.html) | 用来计算在字符串中的有效Python表达式,并返回一个对象 |
| [tuple(s)](https://www.runoob.com/python3/python3-func-tuple.html) | 将序列 s 转换为一个元组                             |
| [list(s)](https://www.runoob.com/python3/python3-att-list-list.html) | 将序列 s 转换为一个列表                             |
| [set(s)](https://www.runoob.com/python3/python-func-set.html) | 转换为可变集合                                      |
| [dict(d)](https://www.runoob.com/python3/python-func-dict.html) | 创建一个字典。d 必须是一个 (key, value)元组序列。   |
| [frozenset(s)](https://www.runoob.com/python3/python-func-frozenset.html) | 转换为不可变集合                                    |
| [chr(x)](https://www.runoob.com/python3/python-func-chr.html) | 将一个整数转换为一个字符                            |
| [ord(x)](https://www.runoob.com/python3/python-func-ord.html) | 将一个字符转换为它的整数值                          |
| [hex(x)](https://www.runoob.com/python3/python-func-hex.html) | 将一个整数转换为一个十六进制字符串                  |
| [oct(x)](https://www.runoob.com/python3/python-func-oct.html) | 将一个整数转换为一个八进制字符串                    |

### 1.2、数字常用方法

| 函数                                                         | 返回值 ( 描述 )                                              |
| :----------------------------------------------------------- | :----------------------------------------------------------- |
| [abs(x)](https://www.runoob.com/python3/python3-func-number-abs.html) | 返回数字的绝对值，如abs(-10) 返回 10                         |
| [ceil(x)](https://www.runoob.com/python3/python3-func-number-ceil.html) | 返回数字的上入整数，如math.ceil(4.1) 返回 5                  |
| cmp(x, y)                                                    | 如果 x < y 返回 -1, 如果 x == y 返回 0, 如果 x > y 返回 1。 **Python 3 已废弃，使用 (x>y)-(x<y) 替换**。 |
| [exp(x)](https://www.runoob.com/python3/python3-func-number-exp.html) | 返回e的x次幂(ex),如math.exp(1) 返回2.718281828459045         |
| [fabs(x)](https://www.runoob.com/python3/python3-func-number-fabs.html) | 返回数字的绝对值，如math.fabs(-10) 返回10.0                  |
| [floor(x)](https://www.runoob.com/python3/python3-func-number-floor.html) | 返回数字的下舍整数，如math.floor(4.9)返回 4                  |
| [log(x)](https://www.runoob.com/python3/python3-func-number-log.html) | 如math.log(math.e)返回1.0,math.log(100,10)返回2.0            |
| [log10(x)](https://www.runoob.com/python3/python3-func-number-log10.html) | 返回以10为基数的x的对数，如math.log10(100)返回 2.0           |
| [max(x1, x2,...)](https://www.runoob.com/python3/python3-func-number-max.html) | 返回给定参数的最大值，参数可以为序列。                       |
| [min(x1, x2,...)](https://www.runoob.com/python3/python3-func-number-min.html) | 返回给定参数的最小值，参数可以为序列。                       |
| [modf(x)](https://www.runoob.com/python3/python3-func-number-modf.html) | 返回x的整数部分与小数部分，两部分的数值符号与x相同，整数部分以浮点型表示。 |
| [pow(x, y)](https://www.runoob.com/python3/python3-func-number-pow.html) | x**y 运算后的值。                                            |
| round(x ,[[n\])](https://www.runoob.com/python3/python3-func-number-round.html) | 返回浮点数x的四舍五入值，如给出n值，则代表舍入到小数点后的位数。 |
| [sqrt(x)](https://www.runoob.com/python3/python3-func-number-sqrt.html) | 返回数字x的平方根。                                          |

**随机数方法**

| 函数                                                         | 描述                                                         |
| :----------------------------------------------------------- | :----------------------------------------------------------- |
| [choice(seq)](https://www.runoob.com/python3/python3-func-number-choice.html) | 从序列的元素中随机挑选一个元素，比如random.choice(range(10))，从0到9中随机挑选一个整数。 |
| [randrange ([start,\] stop [,step])](https://www.runoob.com/python3/python3-func-number-randrange.html) | 从指定范围内，按指定基数递增的集合中获取一个随机数，基数默认值为 1 |
| [random()](https://www.runoob.com/python3/python3-func-number-random.html) | 随机生成下一个实数，它在[0,1)范围内。                        |
| seed([[x\])](https://www.runoob.com/python3/python3-func-number-seed.html) | 改变随机数生成器的种子seed。如果你不了解其原理，你不必特别去设定seed，Python会帮你选择seed。 |
| [shuffle(lst)](https://www.runoob.com/python3/python3-func-number-shuffle.html) | 将序列的所有元素随机排序                                     |
| [uniform(x, y)](https://www.runoob.com/python3/python3-func-number-uniform.html) | 随机生成下一个实数，它在[x,y]范围内。                        |

**三角函数**

| 函数                                                         | 描述                                              |
| :----------------------------------------------------------- | :------------------------------------------------ |
| [acos(x)](https://www.runoob.com/python3/python3-func-number-acos.html) | 返回x的反余弦弧度值。                             |
| [asin(x)](https://www.runoob.com/python3/python3-func-number-asin.html) | 返回x的反正弦弧度值。                             |
| [atan(x)](https://www.runoob.com/python3/python3-func-number-atan.html) | 返回x的反正切弧度值。                             |
| [atan2(y, x)](https://www.runoob.com/python3/python3-func-number-atan2.html) | 返回给定的 X 及 Y 坐标值的反正切值。              |
| [cos(x)](https://www.runoob.com/python3/python3-func-number-cos.html) | 返回x的弧度的余弦值。                             |
| [hypot(x, y)](https://www.runoob.com/python3/python3-func-number-hypot.html) | 返回欧几里德范数 sqrt(x*x + y*y)。                |
| [sin(x)](https://www.runoob.com/python3/python3-func-number-sin.html) | 返回的x弧度的正弦值。                             |
| [tan(x)](https://www.runoob.com/python3/python3-func-number-tan.html) | 返回x弧度的正切值。                               |
| [degrees(x)](https://www.runoob.com/python3/python3-func-number-degrees.html) | 将弧度转换为角度,如degrees(math.pi/2) ， 返回90.0 |
| [radians(x)](https://www.runoob.com/python3/python3-func-number-radians.html) | 将角度转换为弧度                                  |

### 1.3、字符串

#### 1.3.1、转义字符

| 转义字符    | 描述                                                         |
| :---------- | :----------------------------------------------------------- |
| \(在行尾时) | 续行符                                                       |
| \\          | 反斜杠符号                                                   |
| \'          | 单引号                                                       |
| \"          | 双引号                                                       |
| \a          | 响铃                                                         |
| \b          | 退格(Backspace)                                              |
| \000        | 空                                                           |
| \n          | 换行                                                         |
| \v          | 纵向制表符                                                   |
| \t          | 横向制表符                                                   |
| \r          | 回车                                                         |
| \f          | 换页                                                         |
| \oyy        | 八进制数，**yy** 代表的字符，例如：**\o12** 代表换行，其中 o 是字母，不是数字 0。 |
| \xyy        | 十六进制数，yy代表的字符，例如：\x0a代表换行                 |
| \other      | 其它的字符以普通格式输出                                     |

#### 1.3.2、运算符

| 操作符 | 描述                                                         |
| :----- | :----------------------------------------------------------- |
| +      | 字符串连接                                                   |
| *      | 重复输出字符串                                               |
| []     | 通过索引获取字符串中字符                                     |
| [ : ]  | 截取字符串中的一部分，遵循**左闭右开**原则，str[0,2] 是不包含第 3 个字符的。 |
| in     | 成员运算符 - 如果字符串中包含给定的字符返回 True             |
| not in | 成员运算符 - 如果字符串中不包含给定的字符返回 True           |
| r/R    | 原始字符串 - 原始字符串：所有的字符串都是直接按照字面的意思来使用，没有转义特殊或不能打印的字符。 原始字符串除在字符串的第一个引号前加上字母 **r**（可以大小写）以外，与普通字符串有着几乎完全相同的语法。 |
| %      | 格式字符串                                                   |

#### 1.3.3、字符串格式化符号

| 符   号 | 描述                                 |
| :------ | :----------------------------------- |
| %c      | 格式化字符及其ASCII码                |
| %s      | ==格式化字符串==                     |
| %d      | ==格式化整数==                       |
| %u      | 格式化无符号整型                     |
| %o      | 格式化无符号八进制数                 |
| %x      | 格式化无符号十六进制数               |
| %X      | 格式化无符号十六进制数（大写）       |
| %f      | 格式化浮点数字，可指定小数点后的精度 |
| %e      | 用科学计数法格式化浮点数             |
| %E      | 作用同%e，用科学计数法格式化浮点数   |
| %g      | %f和%e的简写                         |
| %G      | %f 和 %E 的简写                      |
| %p      | 用十六进制数格式化变量的地址         |

#### 1.3.4、字符串内置方法

```python
.capitalize() == 首字母变大写
.swapcase() == 大写变小写，小写变大写
.lower() == 变成小写
.upper() == 变成大写
.isalnum() == 判断是否是字母和数字
.isalpha() == 排断是否是字母
.isdigit() == 判断是否是数字
.islower() == 判断是否小写
.isspace() == 判断是否是空格
.istitle() == 判断是否是标题
.isupper() == 判断是否为大写
.isdecimal() == 排断是否只包含十进制字符，是返回True 否则返回False
isinstance() == 判断一个对象是否是一个已知的类型，类似 type(),用法参考第三天练习
.startswith() == 判断是否 xx 字符开始
.endswith() == 判断是否以 xx 字符结束
.count() == 统计某个字符串出现次数
.find() == 寻找字符串的位置，如果没找到，返回 -1，从左到右找
.rfind() ==  寻找字符串的位置，如果没找到，返回 -1，从有到左
.index() == 字符串的位置，如果没找到报错，左到右
.rindex() == 字符串的位置，如果没找到报错，右到左
.decode() == 解码
.encode() == 编码，针对unicode
.format() == 字符串格式化，动态参数，将函数式编程时细说
	
.expandtabs() == 将tab转换成空格，默认一个tab转换成8个空格
.replace(old,new) == 替换，把某个字符替换成别的字符
.join() == 拼接
.splitlines() == 根据换行符分割
.partition() == 分隔，根据某个字符分隔，前，中，后三部分，返回元组，分隔的字符存在，从左到右
.rpartition() == 根据某个字符分隔，前，中，后三部分，从右到左
.split() == 分割，分隔的字符不显示 从左到右
.rsplit()	== 分隔，用什么字符分隔，分隔的字符不显示 从右到左
.rstrip() == 移除右边空白
.lstrip() == 移除左侧空白
.strip() == 移除两段空白
.rjust() == 右对齐
.ljust() == 内容左对齐
.center() == 内容居中
.title() == 变成标题
.translate() == 转换，需要先做一个对应表，最后一个表示删除字符集合
.zfill() == 方法返回指定长度的字符串，原字符串右对齐，前面填充0
```

## 2、数据结构

### 2.1、列表

```python
#列表的方法
a = [1,2,3]
a.append(4) == 追加到列表，最近到最后位置
a.insert(1,'sb') == 在1位置插入sb，可以插入到任意位置
b = [5,6]
a.extend(b) == 批量添加到列表
c = a.pop() == 删除列表的最后一个值，并赋值给c
a.remove(5) == 删除列表的5，如果有多个5，从左到右，删除第一个出现的5
del a[1] == 删除指定索引位置的字符
a.count(5) == 统计5出现的次数
a.index(5) == 获取5的所在的位置
a.reverse() == 翻转排序
a.sort() == 排序，
max(a) == 返回列表最大的值
min(a) == 返回列表最小的值
a.clear() == 清空列表
a.copy() == 复制列表

#元组和列表操作方法一样，元组是不能修改的.
```

### 2.2、字典

```python
#字典的方法
dict = {'1':'fan','2':'huang','3':'hao'}
for i in dict:
    print(i)	# 循环默认输出的是key
--------------------------------------------------------
dict.keys()	== 获取所有的key
dict.values() == 获取字典的值
dict.items() == 获取所有键值对
for k,v in a.items():
    print(k,v)		#循环键值对
--------------------------------------------------------------------
dict.clear() == 清除字典里的所有内容
dict.get(1) == 根据key获取值，如果没有值获取的是None,【索引取值会报错，推荐get】
dict.pop(1) == 删除指定的key的值
del dict['1'] == 删除指定key的键值对
dict.popitem() == 删除最后面的值
-------------------------------------------------------------------
b = {'a':'1'}
dict.update(b) == 把b字典添加到a字典里，[或者dict.update(a=1)]
dict['1']='gx' == 把字典的key 1 修改为gx,如果没有会key 会加到字典里
```

### 2.3、集合

```python
#6.集合的方法
a = set('abracadabra')
b = set('alacazam')
a - b                              # 集合a中包含而集合b中不包含的元素
{'r', 'd', 'b'}
a | b                              # 集合a或b中包含的所有元素
{'a', 'c', 'r', 'd', 'b', 'm', 'z', 'l'}
a & b                              # 集合a和b中都包含了的元素
{'a', 'c'}
a ^ b                              # 不同时包含于a和b的元素
{'r', 'd', 'b', 'm', 'z', 'l'}
-------------------------------------------------------------
.add(a) == 添加元素，参数可以是列表，元组，字典等
.remove(x) == 移除元素，如果元素不存在会报错
.discard(x) == 移除元素，元素不存在不会报错。
.pop() == 随机删除
.update() == 给集合添加元素
.union() == 返回两个集合的并集
.symmetric_differnece()  == 返回两个集合中不重复的元素
.difference() == 返回多个集合的差集
.difference_update() == 移除集合中的元素,该元素在指定的集合也存在
.intersection() == 返回集合的交集
x = {"a", "b", "c"}
y = {"c", "d", "e"}
z = {"f", "g", "c"}
result = x.intersection(y, z)
----------------------------------------------------------------
.isdisjoint()
.issubset()
.issuperset()
```

### 2.4、三元运算

```python
name = 'fan' if 1 == 1 else 'hmm'		#如果条件成立返回fan,不成立返回hmm
```

### 2.5、冒泡排序

```python
li = [1,5,2,4,7,0,9]
for j in range(1,len(li)):
    for i in range(len(li) -j):
        if li[i] < li[i+1]:
            temp = li[i]
            li[i] = li[i+1]
            li[i+1] = temp
print(li)
li.reverse()	#翻转列表
print(li)
#输出结果
[9, 7, 5, 4, 2, 1, 0]
[0, 1, 2, 4, 5, 7, 9]
```

### 2.6、异常处理

```python
#示例
user = input("请输出内容：")
try:
    print(int(user))
except Exception as a:
    print(a)
    print("报错了")

# Exception ==  万能的捕捉报错信息

#2.python中的异常种类非常多，每个异常专门用于处理某一项异常，常用的如下
AttributeError 试图访问一个对象没有的树形，比如foo.x，但是foo没有属性x
IOError 输入/输出异常；基本上是无法打开文件
ImportError 无法引入模块或包；基本上是路径问题或名称错误
IndentationError 语法错误（的子类） ；代码没有正确对齐
IndexError 下标索引超出序列边界，比如当x只有三个元素，却试图访问x[5]
KeyError 试图访问字典里不存在的键
KeyboardInterrupt Ctrl+C被按下
NameError 使用一个还未被赋予对象的变量
SyntaxError Python代码非法，代码不能编译(个人认为这是语法错误，写错了）
TypeError 传入对象类型与要求的不符合
UnboundLocalError 试图访问一个还未被设置的局部变量，基本上是由于另有一个同名的全局变量，
导致你以为正在访问它
ValueError 传入一个调用者不期望的值，即使值的类型是正确的

#3、异常代码结构
try:
    # 主代码块
    pass
except KeyError as e:
    # 异常时，执行该块
    pass
except IndexError as e:
    pass
except Exception as e:
    pass
else:
    # 主代码块执行完，执行该块
    pass
finally:
    # 无论异常与否，最终执行该块
    pass

#4、主动触发异常
try:
    raise Exception('错误了。。。')	# 主动触发错误
except Exception as e:
    print e
```

### 2.7、断言

```python
assert 1 == 2		#条件成立就正常执行，不成立就出错  assert是断言的关键字
```

## 3、函数

### 3.1、操作TXT文件

```python
#1.打开文件的模式：r:只读，w:只写；x:只写(存在则报错)；a:追加； r+:读写；w+:写读；x+：写读；a+:写读; rb,wb,ab这样的是二进制方式打开

f = open(r'E:\System\PyCharm\oldboy\基础\fana.txt','r+',encoding='UTF-8')		#这种方式打开文件一定要close()
print(f.read())
f.close()

with open(r'E:\System\PyCharm\oldboy\基础\fana.txt','r+',encoding='UTF-8') as f:		#推荐这样的写法
    print(r.read())
#2.内置函数
f.read() == 读文本内容
f.readline() == 读一行内容
f.readlines() == 读所有内容，返回的是列表形式，每行是一个值
f.close() == 关闭文件
f.write('你好，fana') == 写内容
f.seek(0) == 调整指针到指定位置
f.tell() == 获取当前指针位置
f.truncate() == 截取文件数据，只保留指针之前的数据
f.fileno() == 文件描述符
f.flush() == 刷新文件缓冲区,保存到硬盘
f.readable() == 是否可读
f.writable() == 是否可写
f.isatty() == 排断文件是否是同意tty设备
```

### 3.2、函数介绍

```python
#1.简单的函数
def fan():
    return 'aaa'
print(fan())

#2.发送邮件函数的写法，传参的方法
import smtplib
from email.mime.text import MIMEText
from email.utils import formataddr

def email(qq):
    msg = MIMEText("邮件内容","plain","utf-8")
    msg['From'] = formataddr(['fan','243662875@qq.com'])
    msg['To'] = formataddr(['走',qq])
    msg['Subject'] = '主题'
    server = smtplib.SMTP('smtp.qq.com',25)
    server.login('243662875@qq.com','kybbjvesigddcahi')
    server.sendmail('243662875@qq.com',[qq,],msg.as_string())
    server.quit()
    
email('772823217@qq.com')

#3.默认传参
def printinfo( name, age = 35 ):	#放在参数尾部
   print ("名字: ", name)
   print ("年龄: ", age)
   return
 
#调用printinfo函数
printinfo( age=50, name="runoob" )
#返回如下
名字:  runoob
年龄:  50

#4.动态传参
def fan(*args,**kwargs):		#一个星表示传的参数放进元组里，二个星表示传的参数放进字典
	print(args, type(args),kwargs, type(kwargs))

a=[1,2,3,4]
fan('a','b',k='v')		#返回('a', 'b') <class 'tuple'>  {'k': 'v'} <class 'dict'>
fan(*a,**{'k1':'v1','k2':'v2'})		#返回(1, 2, 3, 4) <class 'tuple'>  {'k1': 'v1', 'k2': 'v2'} <class 'dict'>


```

### 3.3、lambda表达式

```python
#1.简单的示例
fana = lambda a,b: a+b	#相等于如下函数

def fana1(a,b)
	return a+b
```

### 3.4、内置函数

参考：[菜鸟教程：python3内置函数](https://www.runoob.com/python3/python3-built-in-functions.html) 

| 内置函数                                                     |                                                              |                                                              |                                                              |                                                              |
| :----------------------------------------------------------- | :----------------------------------------------------------- | :----------------------------------------------------------- | :----------------------------------------------------------- | ------------------------------------------------------------ |
| [abs()](https://www.runoob.com/python3/python3-func-number-abs.html) | [dict()](https://www.runoob.com/python/python-func-dict.html) | [help()](https://www.runoob.com/python/python-func-help.html) | [min()](https://www.runoob.com/python3/python3-func-number-min.html) | [setattr()](https://www.runoob.com/python/python-func-setattr.html) |
| [all()](https://www.runoob.com/python/python-func-all.html)  | [dir()](https://www.runoob.com/python/python-func-dir.html)  | [hex()](https://www.runoob.com/python3/python3-func-hex.html) | [next()](https://www.runoob.com/python/python-func-next.html) | [slice()](https://www.runoob.com/python/python-func-slice.html) |
| [any()](https://www.runoob.com/python/python-func-any.html)  | [divmod()](https://www.runoob.com/python3/python3-func-divmod.html) | [id()](https://www.runoob.com/python/python-func-id.html)    | object()                                                     | [sorted()](https://www.runoob.com/python3/python3-func-sorted.html) |
| [ascii()](https://www.runoob.com/python3/python3-func-ascii.html) | [enumerate()](https://www.runoob.com/python3/python3-func-enumerate.html) | [input()](https://www.runoob.com/python/python3-func-input.html) | [oct()](https://www.runoob.com/python/python-func-oct.html)  | [staticmethod()](https://www.runoob.com/python/python-func-staticmethod.html) |
| [bin()](https://www.runoob.com/python/python-func-bin.html)  | [eval()](https://www.runoob.com/python/python-func-eval.html) | [int()](https://www.runoob.com/python/python-func-int.html)  | [open()](https://www.runoob.com/python3/python3-func-open.html) | [str()](https://www.runoob.com/python/python-func-str.html)  |
| [bool()](https://www.runoob.com/python/python-func-bool.html) | [exec()](https://www.runoob.com/python3/python3-func-exec.html) | [isinstance()](https://www.runoob.com/python/python-func-isinstance.html) | [ord()](https://www.runoob.com/python3/python3-func-ord.html) | [sum()](https://www.runoob.com/python/python-func-sum.html)  |
| [bytearray()](https://www.runoob.com/python/python-func-bytearray.html) | [filter()](https://www.runoob.com/python3/python3-func-filter.html) | [issubclass()](https://www.runoob.com/python/python-func-issubclass.html) | [pow()](https://www.runoob.com/python3/python3-func-number-pow.html) | [super()](https://www.runoob.com/python/python-func-super.html) |
| [bytes()](https://www.runoob.com/python3/python3-func-bytes.html) | [float()](https://www.runoob.com/python/python-func-float.html) | [iter()](https://www.runoob.com/python/python-func-iter.html) | [print()](https://www.runoob.com/python/python-func-print.html) | [tuple()](https://www.runoob.com/python3/python3-func-tuple.html) |
| [callable()](https://www.runoob.com/python/python-func-callable.html) | [format()](https://www.runoob.com/python/att-string-format.html) | [len()](https://www.runoob.com/python3/python3-string-len.html) | [property()](https://www.runoob.com/python/python-func-property.html) | [type()](https://www.runoob.com/python/python-func-type.html) |
| [chr()](https://www.runoob.com/python3/python3-func-chr.html) | [frozenset()](https://www.runoob.com/python/python-func-frozenset.html) | [list()](https://www.runoob.com/python3/python3-att-list-list.html) | [range()](https://www.runoob.com/python3/python3-func-range.html) | [vars()](https://www.runoob.com/python/python-func-vars.html) |
| [classmethod()](https://www.runoob.com/python/python-func-classmethod.html) | [getattr()](https://www.runoob.com/python/python-func-getattr.html) | [locals()](https://www.runoob.com/python/python-func-locals.html) | [repr()](https://www.runoob.com/python/python-func-repr.html) | [zip()](https://www.runoob.com/python3/python3-func-zip.html) |
| [compile()](https://www.runoob.com/python/python-func-compile.html) | [globals()](https://www.runoob.com/python/python-func-globals.html) | [map()](https://www.runoob.com/python/python-func-map.html)  | [reversed()](https://www.runoob.com/python3/python3-func-reversed.html) | [__import__()](https://www.runoob.com/python/python-func-__import__.html) |
| [complex()](https://www.runoob.com/python/python-func-complex.html) | [hasattr()](https://www.runoob.com/python/python-func-hasattr.html) | [max()](https://www.runoob.com/python3/python3-func-number-max.html) | [round()](https://www.runoob.com/python3/python3-func-number-round.html) |                                                              |
| [delattr()](https://www.runoob.com/python/python-func-delattr.html) | [hash()](https://www.runoob.com/python/python-func-hash.html) | [memoryview()](https://www.runoob.com/python/python-func-memoryview.html) | [set()](https://www.runoob.com/python/python-func-set.html)  |                                                              |

### 3.5、递归

```python
def num(n):
    if n == 10:
        return n
    n = n +1
    a = num(n)
    return a
```

### 3.6、装饰器

```python
def fan(inde):
    def fzy(*args,**kwargs):
        print('123')
        f = inde(*args,**kwargs)
        print('12344')
        return f
    return fzy

@fan
def index(a,b):
    print('fansss')
    return a+b

print(index(3,4))


#一个函数可以应用多个装饰器,如下
@hmm
@fan
def index(a,b):
    print('fansss')
    return a+b
```

### 3.7、迭代器

```python
#只能访问的能力叫做，迭代器，是访问集合元素的一种方式，从第一个元素开始访问，直到所有的元素访问结束。只能往下访问不能后退。
迭代器的特点：1.仅需要通过next()方法取下一个值，2.不能随机访问，只能从头到尾的访问，3.访问一半时不能退回，4.方便循环比较大的数据，节省内存

a = iter([1,2,3,4,5,6,7,8])

print(a.__next__())
print(a.__next__())
print(a.__next__())
print(a.__next__())

#或者for循环访问：
for i in a:
    print(i)

```

### 3.8、生成器

```python
# 函数里面包含 yield 关键字 就叫做生成器函数，简单写法如下：

def f1():
    yield 1
    print(11)
    yield 2
    print(22)
    yield 3
    print(33)
    yield 4
    print(44)
    yield 5
    print(55)

r = f1()    #仅仅获取一个生成器
ret = r.__next__()  #生成器的next方法，能保存执行状态，下次执行时往下查找yield
print(ret)
ret = r.__next__()  #往下查找yield
print(ret)

#------------------------------------------------------------
def f2():
    start = 0
    while True:
        yield start
        start += 1

r = f2()
a = r.__next__()
b = r.__next__()
c = r.__next__()
print(a,b,c)
```



## 4、常用模块

常用模块：参考：https://www.cnblogs.com/wupeiqi/articles/4963027.html

```python
#0.导入自己定义的模块，在主文件夹下写入__init__.py文件
import 文件名
from lib import 文件名		#从导入自定义文件夹下的某个py文件
from lib import 文件名 as 别名	#定义个别名，方便归类
#如果想让某个模块全局执行可以放在 D:\Python\Lib\site-packages 这个目录下，这个目录下是存放第三方模块的目录

__doc__	#返回py文件的注释
__main__	#如果是主文件，__name__ == "__main__" 否则等于模块名
__file__   #当前文件的路径
__package__  #导入的其他文件，指定文件所在的包
__cached__	 #导入的其他文件，
__builtins__ #存内置函数
1.主文件：调用主函数前，必须加 if __name__ == "__main__":

#安装第三方模块需要用pip3，首先要升级pip3
python -m pip install --upgrade pip	#更新pip模块
pip3 list == 列出安装的模块
pip3 list --outdated == 列出所有过期的库
pip3 install --upgrade 模块名	== 更新某个模块

#更新所有模块
import pip
from pip._internal.utils.misc import get_installed_distributions
from subprocess import call
from time import sleep
for dist in get_installed_distributions():
     call("pip install --upgrade " + dist.project_name, shell=True)

#1.python输入的密码不可见

import getpass
name = input('请输入你的名字：')
passwd = getpass.getpass('请输入你的密码：')
print(name)
print(passwd)

#2.生成随机数，生成数字的随机数
import random,string
passwd = ''
for i in range(6):
    num = random.randrange(0,9)
    passwd += str(num)
print(passwd)

#生成包含数字和字母的随机数
src = string.ascii_letters + string.digits
a = random.sample(src, 6)   #从字母和数字中随机抽取6位
print(''.join(a))
```

### 4.1、正则表达式

正则表达式匹配工具：https://c.runoob.com/front-end/854

```python
#通过 python 的内置 re 模块，实现正则表达式

import re	#导入模块
re.compile(r'\s') == 把正则表达式编译成一个能反复使用的对象

re.findall('fana',' hello fana') == 把匹配到的内容都返回成一个列表
re.match('fan','fannihao fan').group() == 从0位置匹配 匹配是否以fan开通的，若不是就无法匹配
re.search('fan','nihao fana nihao fana') ==  匹配第一个符合规则的字符。返回的是正则对象用group显示匹配的字符
re.finiter() == 匹配的所有字符串，并把他们作为一个迭代器返回

re.search('com','COM',re.I) == 以上可传入工作模式，如下
---------------------------------------------------------------------
re.I == 使匹配对大小写不敏感，
re.L == 做本地化识别
re.M == 多行匹配，影响^和$
re.U == 根据Unicode字符集解析字符
re.S == 使 . 匹配包括换行在内的所有字符
re.X == 可以加注释
---------------------------------------------------------------------
group() == 返回被re匹配的字符串，可以加参数默认为0，返回匹配到的所有组，或者group(n,m) n为组号，m为匹配的字符串
groups() == 返回包含所有小组字符串的元组，
gtoupdict() == 获取匹配到的小组，可以按照re正则返回一个字典，写法(?P<key>需要匹配的正则)
start() == 返回匹配开始的位置
end() == 返回匹配结束的位置
span() == 返回一个元组包含匹配（开始，结束）的位置
---------------------------------------------------------------------

re.sub('fana','fzy',a,2) == 把匹配到的fana,替换成fzy，最后的数字参数 表示替换几次
re.subn('fana','fzy',a) == 和sub一样，返回的参数，最后面的值是给个数字，表示替换了几次
re.split('f',a) == 分隔，分隔字符不显示，以f分隔返回列表

```

#### 4.1.1、正则表达式的元字符

以下内容参考：https://www.runoob.com/regexp/regexp-metachar.html

| 代码 | 说明                                                         |
| ---- | ------------------------------------------------------------ |
| .    | 匹配除换行符（\n）以外的任意字符                             |
| \w   | 匹配字母或数字或下划线或汉字0-9、a-z、A-Z、_（下划线）、汉字和其他国家的语言符号 |
| \W   | 匹配非字母或数字或下划线或汉字，跟\w正好相反                 |
| \s   | 匹配任意的空白符                                             |
| \S   | 匹配任意非空白符                                             |
| \d   | 匹配数字                                                     |
| \D   | 匹配非数字                                                   |
| \b   | 匹配单词的开始或结束                                         |
| ^    | 匹配字符串的开始                                             |
| $    | 匹配字符串的结束                                             |
| []   | 匹配[]中列举的字符                                           |

|          | 常用的反义代码                             |
| -------- | ------------------------------------------ |
| \W       | 匹配任意不是字母，数字，下划线，汉字的字符 |
| \S       | 匹配任意不是空白符的字符                   |
| \D       | 匹配任意非数字的字符                       |
| \B       | 匹配不是单词开头或结束的位置               |
| [^x]     | 匹配除了x以外的任意字符                    |
| [^aeiou] | 匹配除了aeiou这几个字母以外的任意字符      |

|       | 常用的限定符     |
| ----- | ---------------- |
| *     | 重复零次或更多次 |
| +     | 重复一次或更多次 |
| ?     | 重复零次或一次   |
| n}    | 重复n次          |
| {n,}  | 重复n次或更多次  |
| {n,m} | 重复n到m次       |

### 4.2、time模块和datetime	== 时间转换模块

```python
#2.time模块和datetime	== 时间转换模块
improt time,datetime == 导入多个模块可以用逗号分隔
time.sleep(10) == 等待10秒
time.time() == 打印时间戳，从1970年开始
time.ctime() == 当前系统时间
time.gmtime() == 返回TUC的时间，可根据返回的参数，将时间转换自己需要的格式
time.localtime() == 返回本地时间
time.mktime() == 与time.localtime功能相反。需要传个时间对象，转回时间戳格式
time.strftime('%Y-%m-%d %H:%M:%S',time.gmtime()) == 转换成指定的字符串格式
time.strptime('2016-10-01','%Y-%m-%d') == 和上面相反，将字符串格式转换成struct_time格式

datetime.date.today() == 输出格式 2019-09-11
datetime.date.fromtimestamp(time.time()) == 将时间戳转换成日期格式
datetime.datetime.now() == 输出  2019-09-11 15:42:30:334935
datetime.datetime.now().timetuple() == 返回时间对象
datetime.datetime.now().replace(1991,9,26) == 替换年月日
datetime.datetime.strptime("21/9/2018 16:30","%d/%m/%Y %H:%M") == 转换成2018-09-21 16:30:00

datetime.datetime.now() +datetime.timedelta(days=-10) == 当前时间减10天
datetime.datetime.now() +datetime.timedelta(hours=10) == 当前时间加10小时，还有参数seconds秒，weeks周
```

### 4.3、sys模块

```python
#3.sys模块
sys.argv == 获取命令行传入的参数
sys.exit() == 退出程序
sys.version == python版本信息
sys.maxint == 最大的int值
sys.path == 返回模块的搜索路径
sys.path.append() == 添加路径
sys.platform == 返回操作系统平台名称
sys.stderror == 错误相关
sys.stdin == 输入相关
sys.stdin.readline()[:-1] == 读取屏幕的输入
sys.stout == 输出相关
sys.stout.flush() == 强制刷新
sys.stdout.write() == 在屏幕上输出
for i in range(100):		# 打印进度条
    sys.stdout.write('*')
    time.sleep(1)

```

### 4.4、os模块

```python
#4.os模块

os.getcwd()  == 获取当前工作目录
os.chdir() == 改变当前工作路径
os.curdir == 返回当前目录（"."）
os.pardir == 获取当前目录的父目录字符串('..')
os.listdir(path)  == 返回path目录下所有文件列表

os.makedirs(path)  #创建多级目录（如'F:\XXX\SSS'），在F盘下创建XXX目录，继续在XXX目录下创建SSS目录
os.mkdir(path)  #创建path目录（只能创建一级目录，如'F:\XXX\WWW'）,在XXX目录下创建WWW目录

os.removedirs(path)  #删除多级目录（如'F:\XXX\SSS'）,必须为空目录，删除SSS、FFF目录
os.rmdir(path)  #删除path目录(只能删除一级目录，如'F:\XXX\SSS'),只删除SSS目录
os.remove(path)  #删除文件（必须是文件）
os.rename('old','new') #重命名文件或目录

os.stat('path') == 获取文件或目录信息
os.name == 返回当前使用平台的代表字符，Windows用'nt'表示，Linux用'posix'表示
os.sep  == 返回当前操作系统特定的路径分隔符 win 是\\ linux 是 /
os.linesep  #返回当前平台使用的行终止符 win下为"\t\n",Linux下为"\n"
os.environ == 获取系统环境变量

os.pathsep == 用于分割文件路径的字符串
os.system()  #运行shell命令
	os.system('cmd')  #Windows下打开终端
	os.system('ls')  #Linux下查看当前目录所有文件

os.path.abspath(path) #返回path的绝对路径
os.path.split(path)  #将path的目录和文件名分开为元组
os.path.dirname(path)  #返回path中的目录（文件夹部分），结果不包含'\'
os.path.basename(path)  #返回path中的文件名
os.path.join(path1,path2,...)  #将path1，怕path2，...进行组合，若path2为绝对路径，则会将path1删除

os.path.getmtime(path)  #返回文件或目录的最后修改时间，结果为秒数
os.path.getatime(path)  #返回文件或目录的最后访问时间，结果为秒数
os.path.getctime(path)  #返回文件或目录得创建时间，结果为秒
os.path.getsize(path)  #返回文件的大小，若是目录则返回0

os.path.exists(path)  #判断path是否存在，存在返回True,不存在返回False
os.path.isabs(path)  #排断path是否绝对路径，是True,否False
os.path.isfile(path)  #判断path是否为文件，是返回True,不是返回False
os.path.isdir(path)  #判断path是否目录，是返回True，不是返回False
os.path.join(path1[, path2[, ...]])  #将多个路径组合后返回，第一个绝对路径之前的参数将被忽略

os.extsep  #返回文件名与扩展名的分隔符
os.walk(path)   #递归返回path下的目录（包括path目录）、子目录、文件名的三元组
fp=os.popen(cmd)   #打开命令cmd或从命令cmd打开管道，返回值是连接到管道的文件对象
rlt=fp.read()或 rlt=fp.readlines()  #读取结果
```

### 4.5、pickle 和 json 模块

json模块参考：https://www.e-learn.cn/content/qita/2497386

```python
#5.pickle 模块 只能在python用的序列号和反序列化
参考：https://blog.csdn.net/Darkman_EX/article/details/80752049
pickle.dumps(obj) == 序列化 将obj序列化并返回一个bytes对象
pickle.loads(file) == 反序列化,并返回一个对象
pickle.dump(dic,open('db','w')) == 
pickle.load(open('db','r')) == 

#6.json 和pickle模块一样，只是json是所有语言都识别
json.loads() == 将字符串转换成python的基本数据类型
json.dumps() == 将python的基本数据类型转换成字符串

```

### 4.6、XML 模块

```python

#7.xml格式，实现不同语言和程序之间进行数据转换的
from xml.etree import ElementTree as ET	== #导入xml模块
from xml.dom import minidom	== 导入xml模块，功能比较少

fana = ET.parse('fana.xml')
fana.ETementTree() == 类创建
fana.getroot() == 获取xml根节点
fana.write() == 内存中的xml写入文件中
fana.makeelement('tt'{"kk","v"}) == 创建Element对象
fana.remove(fana.root()) == 




# ######################################################################
#7.1解析xml
result = open('xo.xml','r').read()		#打开文件读取xml内容
root = ET.XML(result) == 获取xml的根节点，解析XML格式内容，把字符串解析成XML 

tree = ET.parse('first.xml')  == 另一种解析方式，直接打开并解析文件内容
root = tree.getroot()	获取XML文件的根节点

print(root.tag)	# 顶层标签

#7.2遍历XML文档的所有内容
for child in root:		# 遍历XML文档的第二层
    print(child.tag, child.attrib)	    # 第二层节点的标签名称和标签属性
    for i in child:	    # 遍历XML文档的第三层
        print(i.tag,i.text)	  # 第三层节点的标签名称和内容

#遍历xml中指定的节点
for node in root.iter('year'):		# 遍历XML中所有的year节点
    print(node.tag, node.text)		   # 节点的标签名称和内容

#7.3修改节点内容，是在内存中进行的，如果想报错，就需要将内存中的内容写到文件
print(root.tag)	# 顶层标签
for node in root.iter('year'):		# 循环所有的year节点
    new_year = int(node.text) + 1	# 将year节点中的内容自增一
    node.text = str(new_year)
    node.set('name', 'alex') # 设置属性
    node.set('age', '18')
    del node.attrib['name']	# 删除属性
tree = ET.ElementTree(root)		# 保存文件 
tree.write("newnew.xml", encoding='utf-8')	
tree.write("newnew.xml", xml_declaration=True)	#加上后面的参数顶部会有个注释

#7.4 带缩进保存
def MyWrite(root,file)
	rough_str = ET.tostring(root,'utf-8')
    reparsed = minidom.parseString(rough_str)
    new_str = reparsed,toprettyxml(indent="\t")
    f = open(file,'w',encoding='utf-8')
    f.write(new_str)
    f.close()
#7.5 创建xml，命名空间
参考：https://www.cnblogs.com/wupeiqi/articles/4963027.html
```

### 4.7、hashlib  用于加密相关的操作

```python
#8.hashlib  用于加密相关的操作，主要提供SHA1,SHA224,SHA384,SHA512 MD5算法
# ######## md5 ########
hash = hashlib.md5()	#这种加密存在缺陷，通过撞库可以反解，推荐如下
hashlib.md5(bytes('898oaFs09f',encoding='utf-8'))	#加密算法中添加自定义key再来做加密
hash.update(bytes('admin', encoding='utf-8'))
print(hash.hexdigest())
print(hash.digest())
 
######## sha1 ########
hash = hashlib.sha1()
hash.update(bytes('admin', encoding='utf-8'))
print(hash.hexdigest())
# ######## sha256 ########
hash = hashlib.sha256()
hash.update(bytes('admin', encoding='utf-8'))
print(hash.hexdigest())
# ######## sha384 ########
hash = hashlib.sha384()
hash.update(bytes('admin', encoding='utf-8'))
print(hash.hexdigest())
# ######## sha512 ########
hash = hashlib.sha512()
hash.update(bytes('admin', encoding='utf-8'))
print(hash.hexdigest())
# ######## sha512 ########
import hmac		# hmac 模块也是加密的模块

h = hmac.new(bytes('898oaFs09f',encoding="utf-8"))
h.update(bytes('admin',encoding="utf-8"))
print(h.hexdigest())
```

### 4.8、configparser  处理配置文件模块

```python
#主要用于对特定的配置进行操作，文件的内容格式
[fana]   #节点
k1 = v1  #键值对
k2 : v2
[section] #节点2
k1 = v1

import configparser

con = configparser.ConfigParser()
con.read("fana.txt",encoding='utf-8')   #打开文件读取内容，放入内存

# 1.获取所有节点
result = con.sections()     #内存中寻找 [xxx节点] 格式的文件
print(result)

ret = con.options('fana')   #获取某个[xxx节点] 获取里面的键
print(ret)

ret1 = con.items('fana')    #获取某个节点下的键值对
print(ret1)

ret2 = con.get('fana','k1')     #获取指定节点下的指定key的值
print(ret2)

#2.检查，删除，添加节点

has = con.has_section('fana1')   #检查某个节点是否存在，存在返回True 不存在返回False
print(has)

con.add_section('fanyz')    #添加节点
con.write(open('fana.txt','w',encoding='utf-8'))

con.remove_section('fana')  #删除节点，里面的键值对也会删除
con.write(open('fana.txt','w',encoding='utf-8'))

#3.检查，删除，设置指定组的键值对
con.remove_option('fana','k1')      #删除某个节点下的键值对
con.set('fana','k3','123')      #添加一个键值对
con.set('fana','k2','fana')     #如果存在就修改值
con.write(open('fana.txt','w',encoding='utf-8'))
```

### 4.9、shutil ，文件，文件夹 压缩包 处理模块

可参考：[Python shutil模块](https://www.cnblogs.com/MnCu8261/p/5494807.html)

```python
import shutil	#导入模块

shutil.copyfileobj(open('old.xml','r'), open('new.xml', 'w'))	#将一个文件内容拷贝到另一个文件里
shutil.copyfile('fana.txt','fan.db') #不用打开直接覆盖拷贝
shutil.copy('fana.txt','345.ini') #直接拷贝文件和权限

shutil.rmtree('folder1')	#删除某个文件夹
shutil.move(src, dst)	#移动某个文件夹，相当于重命名
shutil.copytree('src', 'dst', ignore=shutil.ignore_patterns('*.pyc', 'pa*'))	#递归拷贝文件夹下的所有文件到某个目录，可以排除某些名字文件

ret = shutil.make_archive("E:\\abc", 'zip', root_dir='E:\\fab')	#将fab里的文件 压缩成abc.zip

#  ###################################################################
import zipfile		# 压缩和解压

# 压缩
z = zipfile.ZipFile('laxi.zip', 'w')	# 压缩文件 模式w 是写入 a 是把新文件添加到压缩包
z.write('a.log')
z.write('data.data')
z.close()

# 解压
z = zipfile.ZipFile('E:\\abc.zip', 'r')
z.extractall('E:\\fax')	# 可设置解压地址
z.close()

import tarfile	# ---------------------------------------------------------------

# 压缩
tar = tarfile.open('your.tar','w')
tar.add('/Users/wupeiqi/PycharmProjects/bbs2.log', arcname='bbs2.log')
tar.add('/Users/wupeiqi/PycharmProjects/cmdb.log', arcname='cmdb.log')
tar.close()

# 解压
tar = tarfile.open('your.tar','r')
tar.extractall()  
tar.close()

```

### 4.10、subprocess  专门执行命令的模块

```python
import subprocess

ret = subprocess.call("ls -l", shell=True)	#True ，允许 shell 命令是字符串形式,是False 要写成["ls", "-l"]这样的形式
print(ret)

subprocess.check_call(["ls", "-l"])
subprocess.check_call("exit 1", shell=True)		#执行命令，如果执行状态码是 0 ，则返回0，否则抛异常

subprocess.check_output(["echo", "Hello World!"])	#执行命令，如果状态码是 0 ，则返回执行结果，否则抛异常，这种方式可以获得返回结果，以上2
subprocess.check_output("exit 1", shell=True)		#个只能显示。

# =====================================================
subprocess.Popen()		#用于执行复杂的系统命令，也可以执行简单的，推荐。包含参数有很多如下：
#参数：
	shell：同上作用
    args：shell命令，可以是字符串或者序列类型（如：list，元组）
    bufsize：指定缓冲。0 无缓冲,1 行缓冲,其他 缓冲区大小,负值 系统缓冲
    stdin, stdout, stderr：分别表示程序的标准输入、输出、错误句柄
    preexec_fn：只在Unix平台下有效，用于指定一个可执行对象（callable object），它将在子进程运行之前被调用
    close_sfs：在windows平台下，如果close_fds被设置为True，则新创建的子进程将不会继承父进程的输入、输出、错误管道。
    所以不能将close_fds设置为True同时重定向子进程的标准输入、输出与错误(stdin, stdout, stderr)。
    cwd：用于设置子进程的当前目录
    env：用于指定子进程的环境变量。如果env = None，子进程的环境变量将从父进程中继承。
    universal_newlines：不同系统的换行符不同，True -> 同意使用 \n
    startupinfo与createionflags只在windows下有效
    将被传递给底层的CreateProcess()函数，用于设置子进程的一些属性，如：主窗口的外观，进程的优先级等等

#1.输入即可得到输出    
obj = subprocess.Popen("mkdir t3", shell=True, cwd='/home/dev',)	#在/home/dev目录下创建t3目录

#2.如果进入某个环境 在依赖输入，需要如下方法
obj = subprocess.Popen(["python"], stdin=subprocess.PIPE, stdout=subprocess.PIPE, stderr=subprocess.PIPE, universal_newlines=True)
obj.stdin.write("print(1)\n")
obj.stdin.write("print(2)\n")
obj.stdin.write("print(3)\n")
obj.stdin.write("print(2)\n")

cmd_out = obj.stdout.read()			#读取输出的正确的结果
obj.stdout.close()
cmd_error = obj.stderr.read()		#读取错误的结果
obj.stderr.close()

print(cmd_out)
print(cmd_error)

out_error_list = obj.communicate()		#读取正确和错误的结果，拼接的元组方式返回
print(out_error_list)

#3.如果只需要输入单行命令 可以这样操作
obj = subprocess.Popen(["python"], stdin=subprocess.PIPE, stdout=subprocess.PIPE, stderr=subprocess.PIPE, universal_newlines=True)
out_error_list = obj.communicate('print("hello")')
print(out_error_list)

```

### 4.11、logging 模块  用于记录日志的模块

可参考：https://www.cnblogs.com/Nicholas0707/p/9021672.html

```python
import logging		#导入模块

# 1.简单的记录日志方法
logging.basicConfig(filename='log.log',
                    format='%(asctime)s - %(name)s - %(levelname)s -%(module)s:  %(message)s',
                    datefmt='%Y-%m-%d %H:%M:%S %p',
                    level=logging.INFO)

logging.debug('debug')
logging.info('info')
logging.warning('warning')
logging.error('error')
logging.critical('critical')
logging.log(10, 'log')

#2.日志的级别
CRITICAL > ERROR > WARNING > INFO > DEBUG > NOTSET		#只有【当前写等级】大于【日志等级】时，日志文件才被记录

#3.logger 调用方式例子
import logging
def log():
    #创建logger，如果参数为空则返回root logger
    logger = logging.getLogger("nick")
    logger.setLevel(logging.DEBUG)  #设置logger日志等级

    #这里进行判断，如果logger.handlers列表为空，则添加，否则，直接去写日志
    if not logger.handlers:
        #创建handler
        fh = logging.FileHandler("test.log",encoding="utf-8")
        ch = logging.StreamHandler()
        #设置输出日志格式
        formatter = logging.Formatter(
            fmt="%(asctime)s %(name)s %(filename)s %(message)s",
            datefmt="%Y/%m/%d %X"
            )
        #为handler指定输出格式
        fh.setFormatter(formatter)
        ch.setFormatter(formatter)
        #为logger添加的日志处理器
        logger.addHandler(fh)
        logger.addHandler(ch)
    return logger #直接返回logger

4.多日志文件
import logging

access = logging.FileHandler('access.log', 'a', encoding='utf-8')
fmt = logging.Formatter(fmt="%(asctime)s - %(name)s - %(levelname)s -%(filename)s:  %(message)s")
access.setFormatter(fmt)

error = logging.FileHandler('error.log', 'a', encoding='utf-8')
fmt = logging.Formatter()
error.setFormatter(fmt)

# 定义日志
logger1 = logging.Logger('s1', level=logging.ERROR)
logger1.addHandler(access)
logger1.addHandler(error)

logger1.critical('1111')
```

**logging模块中定义好的可以用于format格式字符串说明**

| 字段/属性名称   | 使用格式            | 描述                                                         |
| --------------- | ------------------- | ------------------------------------------------------------ |
| asctime         | %(asctime)s         | 将日志的时间构造成可读的形式，默认情况下是‘2016-02-08 12:00:00,123’精确到毫秒 |
| name            | %(name)s            | 所使用的日志器名称，默认是'root'，因为默认使用的是 rootLogger |
| filename        | %(filename)s        | 调用日志输出函数的模块的文件名； pathname的文件名部分，包含文件后缀 |
| funcName        | %(funcName)s        | 由哪个function发出的log， 调用日志输出函数的函数名           |
| levelname       | %(levelname)s       | 日志的最终等级（被filter修改后的）                           |
| message         | %(message)s         | 日志信息， 日志记录的文本内容                                |
| lineno          | %(lineno)d          | 当前日志的行号， 调用日志输出函数的语句所在的代码行          |
| levelno         | %(levelno)s         | 该日志记录的数字形式的日志级别（10, 20, 30, 40, 50）         |
| pathname        | %(pathname)s        | 完整路径 ，调用日志输出函数的模块的完整路径名，可能没有      |
| process         | %(process)s         | 当前进程， 进程ID。可能没有                                  |
| processName     | %(processName)s     | 进程名称，Python 3.1新增                                     |
| thread          | %(thread)s          | 当前线程， 线程ID。可能没有                                  |
| threadName      | %(thread)s          | 线程名称                                                     |
| module          | %(module)s          | 调用日志输出函数的模块名， filename的名称部分，不包含后缀即不包含文件后缀的文件名 |
| created         | %(created)f         | 当前时间，用UNIX标准的表示时间的浮点数表示； 日志事件发生的时间--时间戳，就是当时调用time.time()函数返回的值 |
| relativeCreated | %(relativeCreated)d | 输出日志信息时的，自Logger创建以 来的毫秒数； 日志事件发生的时间相对于logging模块加载时间的相对毫秒数 |
| msecs           | %(msecs)d           | 日志事件发生事件的毫秒部分。logging.basicConfig()中用了参数datefmt，将会去掉asctime中产生的毫秒部分，可以用这个加上 |



## 5、第三方模块

### 5.1、requests  发送http请求（模拟浏览器浏览网页）

```python
# requests  发送http请求（模拟浏览器浏览网页）
res =requests.get('http://www.baidu.com') == 浏览百度
res.encoding = "utf-8" == 转换编码
sult = res.text == 获取返回的内容
```



## 6、面向对象

### 6.1、反射

```python
#1.通过字符串的形式，导入模块，2.通过字符串的形式找模块，操作其成员
from lib.test import com
r = __import__('lib.test.com',fromlist=True)	#目录比较深的目录 导入的时候写成这样的形式


import fan
inp1 = input("请输入模块：")   #用户输入的模块名
dd = __import__(inp1)        #用字符串的形式导入模块
# f = dd.f1()     #模块中寻找到函数并且执行函数
# print(f)
inp2 = input("请输入要执行的函数：")		#用户输入包含的任意函数名
func = getattr(dd,inp2)  #以字符串的形式去模块中寻找某个函数
print(func())

func = getattr(dd,inp2,None)  #查找函数名，如果没有找到 返回 None
print(func) 

func1 = hasattr(dd,inp2)	#判断函数名是否存在 存在返回True，否则返回False
print(func1)

setattr(dd,'age',18)    #在内存里 给模块设置全局变量
setattr(dd,'age',lambda a: a+1 )    #内存里 设置函数
delattr(dd,'f1')    #内存里删除


#2.反射的用法
#2.1.有个网址 有登陆 退出 等等一些功能。需要调用相关功能,如下做法，根据排断调用相关函数
from lib import account

if url.endswith('login'):
    r = account.login()
    print(r)
elif url.endswith('logout'):
    r = account.logout()
    print(r)
else:
    print('404')
#2.2.以上做法，函数太多的话一个一个写，就比较麻烦，根据反射的方式，可以简单解决。
url = input("请输入url:")
inp = url.split('/')[-1]
if hasattr(account,inp):
    target = getattr(account,inp)
    r = target()
    print(r)
else:
    print('404')

#2.3.如果模块太多就不适应，检测输入的模块，根据输入的模块查找函数。

url = input("请输入url:")
module,func = url.split('/')
mod = __import__('lib.'+module,fromlist=True)
if hasattr(mod,func):
    target = getattr(mod,func)
    r = target()
    print(r)
else:
    print('404')
```

### 6.2、面向对象基础

1.面向对象不是所有情况都适用

2.面向对象编程

​	a.定义类：class 类名：

​							def 方法1(self,bb)

​									pass

​	b.根据类创建对象，使用对象去执行类中的方法

3.self 是个形式参数，python内部传递的，他是传递的 对象

```python
#1.面向对象编程写法
class oldboy:		#创建类
    def fetch(self,back):
        return back
    def record(self,back,record):
        a = back + record
        return a
obj = oldboy()      #创建对象
print(obj.fetch('www'))
print(obj.record(1,2))

#1.1.创建类就可以有两种方式:
class Foo(object):		#普通方式
   def func(self):
      print('hello word')

def func(self):			#特殊方式
    print('hello word')
Foo = type('Foo', (object,), {'func': func})

#2.面向对象特性 -- 封装
#	使用场景1，同一个类的方法具有相同参数时，直接封装对象即可，场景2：把类当做模块，创建多个对象（对象内封装的数据可以不一样）
class oldboy:
    def fetch(self):
        print(self.back)
    def record(self,record):
        a = self.back + record
        return a
    def fzy(self,back,record):
        a = back + record
        return a
obj = oldboy()
obj.back = 'oldboy'		#封装的一种方式，非主流的方式
obj.fetch()		#返回 oldboy

obj.back = 1
print(obj.record(2))	#返回3

#2.1 __init__ 构造方法
class oldboy:
    def __init__(self,name,age):     #init有个特殊的名字：构造方法
        self.name = name
        self.age = age

    def fetch(self):
        print(self.name)
        #print(self.age)

    def record(self,record):
        a = self.age + record
        return a

obj = oldboy('fana',18)
obj.fetch()     #返回fana
print(obj.record(3))    #返回21


#3.面向对象特性 -- 继承。简单写法如下

class fana:     #(基类)
    def chi(self):
        print(self.name + "吃")
    def he(self):
        print(self.name + "喝")
    def piao(self):
        print("爱票")
class cat:
    def __init__(self,name):
        self.name = name
    def jiao(self):
        print('瞄')
    def he(self):
        print(self.name + "不喝")

class dog(fana,cat):    #(派生类) 继承了fana和cat这个类,就是说可以继承多个类，
    def __init__(self,name):
        self.name = name
    def jiao(self):
        print(self.name + ' 汪')
    def piao(self):
        print("不爱票")


alex = dog("小明")   #创建对象
alex.jiao()     #返回 小明 汪
alex.chi()      #返回 小明 吃
alex.he()       #返回 小明 喝    如果本事没有，继承来的类有相同的函数，是按照从做到右的基类里查找，所有查到fana这个类
alex.piao()     #返回 不爱票     基类和派生类 都存在相同函数的话，优先找自己类下面的

#继承查找关系 自己 > 从左 > 左的基类 > 到右 > 右的基类 > 左和右相同的基类

class hmm:
    def __init__(self):
        print("hmm的构造方法")
        self.fan = 'hmm'
        self.zy = 'ziy'
    def fan(self):
        print('你好',self.fan)

class cat(hmm):
    def __init__(self):
        print('cat的构造方法')
        self.n = '吃喝'
        super(cat,self).__init__()		#这样写就可以继承基类的构建方法(推荐)
        hmm.__init__(self)		#不推荐
    def fzy(self):
        print(self.n)

ret = cat()
print(ret.__dict__)


#3.面向对象特性 -- 多态 python本就是多态

```

### 6.3、类 成员

```python
class hmm:
    coun = 'china'  #静态字段，可以将每个对象都构建的字段 放到类中
    def __init__(self,name):
        print("hmm的构造方法")
        self.zy = name    #普通字段 在对象中
        #self.coun = 'chian'
    def fan(self):      #普通方法，在类中
        print('你好',self.zy,self.coun)

    @staticmethod       #加上这个 就是静态方法
    def xx(args):
        print(args)
    @classmethod        #加上这个 就是类方法
    def oo(cls,args):   #类方法必须加上cls参数
        print(args)

    @property           #特性 也有叫属性，将方法伪造成一个字段
    def end(self):      #加上property 后这里不能在传递字段了
        temp = "hello %s" % self.zy
        return temp
    @end.setter         #如果需要重新赋值特性的值,需要写个同名的函数，加上这个xxx.setter
    def end(self,value):    #xxx表示函数名必须一样,value表示接受设置的值
        self.zy = value


beijing = hmm('fan')
print(beijing.end)      #获取特性
beijing.end = '123456'
print(beijing.end)      #打印设置后的值hello 123456

henai = hmm('河南')     #创建对象
henai.fan()           #获取对象的方法
xiangang = hmm('香港')
xiangang.fan()

print(hmm.coun)     #获取静态字段
hmm.xx(123)         #获取静态方法
hmm.oo(1234)        #获取类方法

#注意：
通过类访问：  静态字段(每个对象都有一份的时候用)，静态方法（不使用对象封装的内容），类方法；
通过对象访问：普通字段(每个对象都不同的数据)； 普通方法(使用对象的数据)；特性（将方法伪造成字段）

快速判断：是类执行还是对象执行，带有self 对象相同， 无self 类调用
```

### 6.4、成员修饰符

```python
# 成员包含 普通字段，静态字段，普通方法，静态方法，类方法，普通特性

class Foo:
    x = '这共用的，都可以访问'
    __ox = '这是内部访问的'    #静态字段这样就是只能在自己的类里面访问，继承类都访问不了

    def __init__(self,bk):
        self.__bk = bk      #普通字段这样变成私有的
    def __fet(self):          #所以加上两个下划线就变成私有的了，只能内部访问
        print(Foo.__ox)
        print(self.__bk)
    def ff(self):
        self.__fet()    #通过访问共有的就可以调用私有的


print(Foo.x)
#print(Foo.__x)     #外部访问报错
fan = Foo('f')
fan.ff()

fan._Foo__fet()     #非要访问这样也可以 但不建议

```

### 6.5、类的特殊成员方法

```python
__doc__  		#表示类的描述信息
__module__ 		#表示当前操作的对象在哪个个模块
__class__     	#表示当前操作的对象的类是什么
__init__ 		#构造方法，通过类创建对象时，自动触发执行
__del__			#析构方法，当对象在内存中被释放时，自动触发执行
__call__ 		#对象后面加括号，触发执行
__dict__ 		#查看类或对象中的所有成员 
__str__			#如果一个类中定义了__str__方法，那么在打印 对象 时，默认输出该方法的返回值
__getitem__		#用于索引操作，如字典。表示获取数据
__setitem__		#表示设置数据
__delitem__		#表示删除数据
__new__
__metaclass__
```

### 6.6、单例模式

```python
#单例模式什么时候使用。当所有的实例中封装的数据相同时，使用单例模式

import random

class sqlpool:
    __instance = None
    def __init__(self):
            self.ip = '10.10.10.11'
            self.port = '3306'
            self.user = 'mysql'
            self.pawd = '123456'
    @staticmethod
    def instan():         #静态方法加上静态字段的方式伪造成单例模式
        if sqlpool.__instance:
            return sqlpool.__instance
        else:
            sqlpool.__instance = sqlpool()
            return sqlpool.__instance
    def conn(self):
        ret = random.randrange(1,11)
        return ret

my = sqlpool()		#传递方式创建对象
for i in range(10):
    print("去连接池",my)
    conn = my.conn()
    print('获取的连接',conn)
 
p = sqlpool.instan()	#单实例模式创建对象
for i in range(10):
    print("去连接池",p)
    conn = p.conn()
    print('获取的连接',conn)
```

## 7、网络编程

### 7.1、Socket（套接字）

于描述IP地址和端口，是一个通信链的句柄，应用程序通常通过"套接字"向网络发出请求或者应答网络请求

参考：https://www.cnblogs.com/wupeiqi/articles/5040823.html

```python
#1.简单代码：聊天机器人，服务端编写如下：
import socket   #导入socket模块

sk = socket.socket()    #创建对象
sk.bind(('127.0.0.1',8080,))    #设置服务端的ip
sk.listen(5)    #表示最多5个连接数
while True:
    conn,address = sk.accept()     #接收客户端的请求，阻塞实时等待，
    conn.sendall(bytes("欢迎来电", encoding='utf-8'))	#发送消息
    while True:
        result = conn.recv(1024)  # 阻塞
        ret_str = str(result, encoding='utf-8')
        if ret_str == 'q':
            break
        conn.sendall(bytes(ret_str + " 哈哈", encoding='utf-8'))
    print(conn,address)

#2.客服端编写如下
import socket

obj = socket.socket()
obj.connect(('127.0.0.1',8080,))    #连接服务端
result = obj.recv(1024)             #阻塞
ret_str = str(result,encoding='utf-8')
print(ret_str)
while True:
    msc = input("请输入：")
    if msc == 'q':
        obj.sendall(bytes(msc, encoding='utf-8'))
        break
    else:
        obj.sendall(bytes(msc,encoding='utf-8'))
        ret = str(obj.recv(1024),encoding='utf-8')
        print(ret)
obj.close()     #关闭


# ===================================
#文件上传 服务端
import socket   #导入socket模块
sk = socket.socket()    #创建对象
sk.bind(('127.0.0.1',8080,))    #设置服务端的ip
sk.listen(5)    #表示最多5个连接数

while True:
    conn,address = sk.accept()     #接收客户端的请求，阻塞实时等待，
    conn.sendall(bytes("欢迎登陆", encoding='utf-8'))
    #先接收文件大小，在开始接收文件内容
    fi_size = str(conn.recv(1024),encoding='utf-8')
    conn.sendall(bytes("续传", encoding='utf-8'))

    total = int(fi_size)        #文件总大小
    has_size = 0        #已接收的文件大小
    with open('new_file','wb') as file:
        while True:
            if has_size == total:
                break
            data = conn.recv(1024)
            file.write(data)
            has_size += len(data)

#客户端
import socket,os

obj = socket.socket()
obj.connect(('127.0.0.1',8080,))    #连接服务端

result = obj.recv(1024)             #阻塞
ret_str = str(result,encoding='utf-8')
print(ret_str)
#发送当前文件大小
size = os.stat('error.log').st_size
obj.sendall(bytes(str(size),encoding='utf-8'))
obj.recv(1024)
#发送文件
with open('error.log','rb') as f:
    for line in f:
        obj.sendall(line)
obj.close()
```

#### 7.1.1、socket的方法

```python
#socket的更多方法

sk = socket.socket(socket.AF_INET,socket.SOCK_STREAM,0)
参数一：地址簇
　　socket.AF_INET IPv4（默认）
　　socket.AF_INET6 IPv6
　　socket.AF_UNIX #只能够用于单一的Unix系统进程间通信
参数二：类型
　　socket.SOCK_STREAM	#流式socket , for TCP （默认）
　　socket.SOCK_DGRAM　　 #数据报式socket , for UDP
　　socket.SOCK_RAW #原始套接字，普通的套接字无法处理ICMP、IGMP等网络报文，而SOCK_RAW可以；其次，SOCK_RAW也可以处理特殊的IPv4报文；此外，利用原始套接字，可以通过IP_HDRINCL套接字选项由用户构造IP头。
　　socket.SOCK_RDM #是一种可靠的UDP形式，即保证交付数据报但不保证顺序。SOCK_RAM用来提供对原始协议的低级访问，在需要执行某些特殊操作时使用，如发送ICMP报文。SOCK_RAM通常仅限于高级用户或管理员运行的程序使用。
　　socket.SOCK_SEQPACKET #可靠的连续数据包服务
参数三：协议
　　0　　#（默认）与特定的地址家族相关的协议,如果是 0 ，则系统就会根据地址格式和套接类别,自动选择一个合适的协议
    
sk.bind(address)
　　#s.bind(address) 将套接字绑定到地址。address地址的格式取决于地址族。在AF_INET下，以元组（host,port）的形式表示地址。
sk.listen(backlog)
　　#开始监听传入连接。backlog指定在拒绝连接之前，可以挂起的最大连接数量。
    #backlog等于5，表示内核已经接到了连接请求，但服务器还没有调用accept进行处理的连接个数最大为5
    #这个值不能无限大，因为要在内核中维护连接队列
sk.setblocking(bool)
	#是否阻塞（默认True），如果设置False，那么accept和recv时一旦无数据，则报错。
sk.accept()
　　#接受连接并返回（conn,address）,其中conn是新的套接字对象，可以用来接收和发送数据。address是连接客户端的地址。
　　#接收TCP 客户的连接（阻塞式）等待连接的到来
sk.connect(address)
　　#连接到address处的套接字。一般，address的格式为元组（hostname,port）,如果连接出错，返回socket.error错误。
sk.connect_ex(address)
　　#同上，只不过会有返回值，连接成功时返回 0 ，连接失败时候返回编码，例如：10061
sk.close()
　　#关闭套接字
sk.recv(bufsize[,flag])
　　#接受套接字的数据。数据以字符串形式返回，bufsize指定最多可以接收的数量。flag提供有关消息的其他信息，通常可以忽略。
sk.recvfrom(bufsize[.flag])
　　#与recv()类似，但返回值是（data,address）。其中data是包含接收数据的字符串，address是发送数据的套接字地址。
sk.send(string[,flag])
　　#将string中的数据发送到连接的套接字。返回值是要发送的字节数量，该数量可能小于string的字节大小。即：可能未将指定内容全部发送。
sk.sendall(string[,flag])
　　#将string中的数据发送到连接的套接字，但在返回之前会尝试发送所有数据。成功返回None，失败则抛出异常。
   #内部通过递归调用send，将所有内容发送出去。
sk.sendto(string[,flag],address)
　　#将数据发送到套接字，address是形式为（ipaddr，port）的元组，指定远程地址。返回值是发送的字节数。该函数主要用于UDP协议。
sk.settimeout(timeout)
　　#设置套接字操作的超时期，timeout是一个浮点数，单位是秒。值为None表示没有超时期。一般，超时期应该在刚创建套接字时设置，因为它们可能用于连接的操作（如 client 连接最多等待5s ）
sk.getpeername()
　　#返回连接套接字的远程地址。返回值通常是元组（ipaddr,port）。
sk.getsockname()
　　#返回套接字自己的地址。通常是一个元组(ipaddr,port)
sk.fileno()
　　#套接字的文件描述符
```

#### 7.1.2、socketserver 模块[实现并发]

```python
#服务端
import socketserver

class MyServer(socketserver.BaseRequestHandler):	#必须要继承这个类
    def handle(self):
        # print self.request,self.client_address,self.server
        conn = self.request
        conn.sendall(bytes('欢迎致电 10086，请输入1xxx,0转人工服务.',encoding='utf-8'))
        Flag = True
        while Flag:
            data = conn.recv(1024)
            if data == 'exit':
                Flag = False
            elif data == '0':
                conn.sendall(bytes('通过可能会被录音.balabala一大推',encoding='utf-8'))
            else:
                conn.sendall(bytes('请重新输入.',encoding='utf-8'))

if __name__ == '__main__':
    server = socketserver.ThreadingTCPServer(('127.0.0.1',8009),MyServer)
    server.serve_forever()

#客户端
import socket

ip_port = ('127.0.0.1',8009)
sk = socket.socket()
sk.connect(ip_port)
sk.settimeout(5)

while True:
    data = sk.recv(1024)
    print('receive:',str(data,encoding='utf-8'))
    inp = input('please input:')
    sk.sendall(bytes(inp,encoding='utf-8'))
    if inp == 'exit':
        break
sk.close()
```

#### 7.1.3、I/O多路复用

I/O多路复用指：通过一种机制，可以监视多个描述符，一旦某个描述符就绪（一般是读就绪或者写就绪），能够通知程序进行相应的读写操作。

Python中有一个select模块，其中提供了：select、poll、epoll三个方法，分别调用系统的 select，poll，epoll 从而实现IO多路复用

*==注意：网络操作、文件操作、终端操作等均属于IO操作，对于windows只支持Socket操作，其他系统支持其他IO操作，但是无法检测 普通文件操作 自动上次读取是否已经变化。==*

```python
#1.简单示例如下：服务端
import socket
import select

sk1 = socket.socket()
sk1.bind(("127.0.0.1", 8080))
sk1.listen(5)

sk2 = socket.socket()
sk2.bind(("127.0.0.1", 8081))
sk2.listen(5)

li = [sk1, sk2]
while True:     #select 内部自动监听sk1,sk2 两个对象
    a, b, c = select.select(li, [], [], 5)     #句柄列表a, 句柄列表b, 句柄列表c = select.select(句柄序列1, 句柄序列2, 句柄序列3, 超时时间)   参数： 可接受四个参数（前三个必须）  返回值：三个列表
    print(a,b,c)
    for sk in a:
        conn, address = sk.accept()     #表示每个链接对象
        conn.sendall(bytes('hello', encoding='utf-8'))
        conn.close()
# select方法用来监视文件句柄，如果句柄发生变化，则获取该句柄。
	1、当 参数1 序列中的句柄发生可读时（accetp和read），则获取发生变化的句柄并添加到 返回值1 序列中
	2、当 参数2 序列中含有句柄时，则将该序列中所有的句柄添加到 返回值2 序列中
	3、当 参数3 序列中的句柄发生错误时，则将该发生错误的句柄添加到 返回值3 序列中
	4、当 超时时间 未设置，则select会一直阻塞，直到监听的句柄发生变化
    当 超时时间 ＝ 1时，那么如果监听的句柄均无任何变化，则select会阻塞 1 秒，之后返回三个空列表，如果监听的句柄有变化，则直接执行。

        
#客户端client 1
import socket

ip_port = ('127.0.0.1',8080)
sk = socket.socket()
sk.connect(ip_port)
sk.settimeout(5)
data = sk.recv(2048)
print('receive:',str(data,encoding='utf-8'))
sk.close()

#客户端client 2
import socket

ip_port = ('127.0.0.1',8081)
sk = socket.socket()
sk.connect(ip_port)
sk.settimeout(5)
data = sk.recv(2048)
print('receive:',str(data,encoding='utf-8'))

sk.close()


#2.聊天机器人 示例：
import socket
import select

sk1 = socket.socket()
sk1.bind(('127.0.0.1', 8081))
sk1.listen(5)
li = [sk1, ]
while True:
    a, b, c = select.select(li, [], li, 2)
    print("正在监听的对象 " + str(len(li)))
    print(a, b, c)
    for sk in a:
        if sk == sk1:
            conn, address = sk.accept()
            li.append(conn)
        else:
            try:
                recv = sk.recv(1024)
                msc = str(recv, encoding='utf-8')
                sk.sendall(bytes(msc, encoding='utf-8'))
            except Exception as err:
                li.remove(sk)


#客户端
import socket

obj = socket.socket()
obj.connect(('127.0.0.1', 8081))
#sk.settimeout(5)
while True:
    inp = input("请输入>>>")
    obj.sendall(bytes(inp,encoding='utf-8'))
    data = obj.recv(1024)
    print(str(data,encoding='utf-8'))
obj.close()

#3.聊天机器人读写分离，服务端版，客户端不需要变
import socket
import select

sk1 = socket.socket()
sk1.bind(('127.0.0.1', 8081))
sk1.listen(5)
inputs = [sk1, ]
out = []
dic = {}
while True:
    a, b, c = select.select(inputs, out, inputs, 2)
    print("正在监听的对象 " + str(len(inputs)))
    print(a, b, c)
    for sk in a:
        if sk == sk1:
            conn, address = sk.accept()
            inputs.append(conn)
            dic[conn] = []
        else:
            try:
                recv = sk.recv(1024)
            except Exception as err:
                inputs.remove(sk)
            else:
                msc = str(recv, encoding='utf-8')
                dic[sk].append(msc)
                out.append(sk)
    for conn in b:
        recv_str = dic[conn][0]
        del dic[conn][0]
        conn.sendall(bytes(recv_str,encoding='utf-8'))
        out.remove(conn)
    for k in c:
        inputs.remove(k)
```

## 7.2、线程、进程、协程

[参考：武沛齐博客](https://www.cnblogs.com/wupeiqi/articles/4839959.html)		[武沛齐博客](https://www.cnblogs.com/wupeiqi/articles/5040827.html)

```python
#1.进程：进程就是一个程序在一个数据集上的一次动态执行过程。进程一般由程序、数据集、进程控制块三部分组成
	优点：同时利用多个CPU，能同时进行多个操作
    缺点：耗费资源（需重新开辟内存空间）

#2.线程：
	优点：共享内存，I/O操作时候创造并发操作
    缺点：抢占资源

#注：进程不是越多越好，CPU个数=进程个数，线程也不是越多越好，具体案例需具体分析，请求上下文切换耗时

#进程与线程之间的关系：线程是属于进程的，线程运行在进程空间内，同一进程所产生的线程共享同一内存空间，当进程退出时该进程所产生的线程都会被强制退出并清除
```

[参考：博客园](https://www.cnblogs.com/resn/p/5591419.html)

```python
#1.threading模块：Threading用于提供线程相关的操作，线程是应用程序中工作的最小单元
import threading
import time
 
def worker(num):
    """
    thread worker function
    :return:
    """
    time.sleep(1)
    print("Thread %d" % num)
    return
 
for i in range(20):
    t = threading.Thread(target=worker,args=(i,)，name=“t.%d” % i)
    t.start()
#上述代码创建了10个“前台”线程，然后控制器就交给了CPU，CPU根据指定算法进行调度，分片执行指令

# threading.thread方法说明：
	t.start() :	 	#激活线程
	t.getName() : 	#获取线程的名称
	t.setName() ： 	#设置线程的名称 
	t.name : 	#获取或设置线程的名称
	t.is_alive() ： 	#判断线程是否为激活状态
	t.isAlive() ：	#判断线程是否为激活状态
	t.setDaemon() 	#设置为后台线程或前台线程（默认：False）;通过一个布尔值设置线程是否为守护线程，必须在执行start()方法之后才可以使用。如果是后台线程，主线程执行过程中，后台线程也在进行，主线程执行完毕后，后台线程不论成功与否，均停止；如果是前台线程，主线程执行过程中，前台线程也在进行，主线程执行完毕后，等待前台线程也执行完成后，程序停止
	t.isDaemon() ： 	#判断是否为守护线程
	t.ident ：	#获取线程的标识符。线程标识符是一个非零整数，只有在调用了start()方法之后该属性才有效，否则它只返回None。
	t.join() ：	#逐个执行每个线程，执行完毕后继续往下执行，该方法使得多线程变得无意义
	t.run() ：	#线程被cpu调度后自动执行线程对象的run方法

#2.线程锁 threading.RLock和threading.Lock
# 我们使用线程对数据进行操作的时候，如果多个线程同时修改某个数据，可能会出现不可预料的结果，为了保证数据的准确性，引入了锁的概念

import threading,time

globals_num = 0
lock = threading.RLock()	#创建对象

def fun():
    lock.acquire()  #获得锁
    global globals_num
    globals_num += 1
    time.sleep(0.5)
    print(globals_num)
    lock.release()  #释放锁

for i in range(10):
    t = threading.Thread(target=fun)
    t.start()
    
#2.1.threading.RLock和threading.Lock 的区别：
	RLock允许在同一线程中被多次acquire。而Lock却不允许这种情况。 如果使用RLock，那么acquire和release必须成对出现，即调用了n次acquire，必须调用n次的release才能真正释放所占用的琐

#2.2.互斥锁 同时只允许一个线程更改数据，而Semaphore是同时允许一定数量的线程更改数据 ，比如厕所有3个坑，那最多只允许3个人上厕所，后面的人只能等里面有人出来了才能再进去
import threading,time
 
def run(n):
    semaphore.acquire()
    time.sleep(1)
    print("run the thread: %s" %n)
    semaphore.release()
 
if __name__ == '__main__':
    num= 0
    semaphore  = threading.BoundedSemaphore(5) #最多允许5个线程同时运行
    for i in range(20):
        t = threading.Thread(target=run,args=(i,))
        t.start()

#3.threading.Event
	#Event是线程间通信最间的机制之一：一个线程发送一个event信号，其他的线程则等待这个信号。用于主线程控制其他线程的执行.
包含方法：
	Event.wait([timeout]) ： 堵塞线程，直到Event对象内部标识位被设为True或超时（如果提供了参数timeout）。
	Event.set() ：将标识位设为Ture
	Event.clear() ： 将标识位设为False。
	Event.isSet() ：判断标识位是否为Ture。
#当线程执行的时候，如果flag为False，则线程会阻塞，当flag为True的时候，线程不会阻塞。它提供了本地和远程的并发性
import threading
 
def do(event):
    print('start')
    event.wait()
    print('execute')
 
event_obj = threading.Event()
for i in range(10):
    t = threading.Thread(target=do, args=(event_obj,))
    t.start()
 
event_obj.clear()
inp = input('input:')
if inp == 'true':
    event_obj.set()
    
#4.threading.Condition：使得线程等待，只有满足某条件时，才释放n个线程

import threading
import time
def consumer(cond):
    with cond:
        print("consumer before wait")
        cond.wait()
        print("consumer after wait")
 
def producer(cond):
    with cond:
        print("producer before notifyAll")
        cond.notifyAll()
        print("producer after notifyAll")
 
condition = threading.Condition()
c1 = threading.Thread(name="c1", target=consumer, args=(condition,))
c2 = threading.Thread(name="c2", target=consumer, args=(condition,))
p = threading.Thread(name="p", target=producer, args=(condition,))
 
c1.start()
time.sleep(2)
c2.start()
time.sleep(2)
p.start()
```

```python
#1.queue模块:就是对队列，它是线程安全的。这个模型也叫生产者-消费者模型

import queue

q = queue.Queue(maxsize=0)  # 构造一个先进显出队列，maxsize指定队列长度，为0 时，表示队列长度无限制。

q.join()    # 等到队列为kong的时候，在执行别的操作
q.qsize()   # 返回队列的大小 （不可靠）
q.empty()   # 当队列为空的时候，返回True 否则返回False （不可靠）
q.full()    # 当队列满的时候，返回True，否则返回False （不可靠）
q.put(item, block=True, timeout=None) #  将item放入Queue尾部，item必须存在，可以参数block默认为True,表示当队列满时，会等待队列给出可用位置，为False时为非阻塞，此时如果队列已满，会引发queue.Full 异常。 可选参数timeout，表示 会阻塞设置的时间，过后， 如果队列无法给出放入item的位置，则引发 queue.Full 异常
q.get(block=True, timeout=None) #   移除并返回队列头部的一个值，可选参数block默认为True，表示获取值的时候，如果队列为空，则阻塞，为False时，不阻塞，若此时队列为空，则引发 queue.Empty异常。 可选参数timeout，表示会阻塞设置的时候，过后，如果队列为空，则引发Empty异常。
q.put_nowait(item) #   等效于 put(item,block=False)
q.get_nowait() #    等效于 get(item,block=False)


#生产者 -- 消费者
import Queue
import threading

message = Queue.Queue(10)

def producer(i):
    while True:
        message.put(i)

def consumer(i):
    while True:
        msg = message.get()

for i in range(12):
    t = threading.Thread(target=producer, args=(i,))
    t.start()

for i in range(10):
    t = threading.Thread(target=consumer, args=(i,))
    t.start()
```

```python
#1.multiprocessing模块: multiprocessing是python的多进程管理包，和threading.Thread类似。直接从侧面用subprocesses替换线程使用GIL的方式，由于这一点，multiprocessing模块可以让程序员在给定的机器上充分的利用CPU。

# 在multiprocessing中，通过创建Process对象生成进程，然后调用它的start()方法

from multiprocessing import Process
 
def f(name):
    print('hello', name)
 
if __name__ == '__main__':
    p = Process(target=f, args=('bob',))
    p.start()
    p.join()
    
#2.进程池

from multiprocessing import pool	#导出进程池


#2.1.进程池的方法
apply(func[, args[, kwds]]) ：使用arg和kwds参数调用func函数，结果返回前会一直阻塞，由于这个原因，apply_async()更适合并发执行，另外，func函数仅被pool中的一个进程运行。
apply_async(func[, args[, kwds[, callback[, error_callback]]]]) ： apply()方法的一个变体，会返回一个结果对象。如果callback被指定，那么callback可以接收一个参数然后被调用，当结果准备好回调时会调用callback，调用失败时，则用error_callback替换callback。 Callbacks应被立即完成，否则处理结果的线程会被阻塞。
close() ： 阻止更多的任务提交到pool，待任务完成后，工作进程会退出。
terminate() ： 不管任务是否完成，立即停止工作进程。在对pool对象进程垃圾回收的时候，会立即调用terminate()。
join() : wait工作线程的退出，在调用join()前，必须调用close() or terminate()。这样是因为被终止的进程需要被父进程调用wait（join等价与wait），否则进程会成为僵尸进程。
map(func, iterable[, chunksize])
map_async(func, iterable[, chunksize[, callback[, error_callback]]])
imap(func, iterable[, chunksize])
imap_unordered(func, iterable[, chunksize])
starmap(func, iterable[, chunksize])
starmap_async(func, iterable[, chunksize[, callback[, error_back]]])
```

```python



```







## 8、数据库操作

















